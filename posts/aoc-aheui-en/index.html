<!doctype html> <html lang=en > <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155225320-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-155225320-2'); </script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.ico"> <title>Solving (and Animating) Advent of Code Day 1 with 아희</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>theoretically good with computers</a>.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">home</a> <a class="sidebar-nav-item " href="/posts/">posts</a> <a class="sidebar-nav-item " href="https://dblp1.uni-trier.de/pers/hd/c/Cognetta:Marco">publications</a> <a class="sidebar-nav-item " href="https://github.com/mcognetta">github</a> <a class="sidebar-nav-item " href="https://www.linkedin.com/in/mcognetta/">linkedin</a> <a class="sidebar-nav-item " href="https://twitter.com/good_in_theory">twitter</a> <a class="sidebar-nav-item " href="assets/mccv.pdf">cv</a> <a class="sidebar-nav-item " href="/tags">all tags</a> </nav> <div class=sidebar-item > <p>&copy; Marco Cognetta.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home >marco cognetta</a> <small>theoretically good with computers</small> </h3> </div> </div> <div class="container content"> <div class=franklin-content ><h1 id="solving_and_animating_advent_of_code_day_1_with_아희"><a href="#solving_and_animating_advent_of_code_day_1_with_아희" class=header-anchor >Solving &#40;and Animating&#41; Advent of Code Day 1 with 아희</a></h1> <p><em>The original Korean version of this post can be found <a href="https://mcognetta.github.io/posts/aoc-aheui-kr/">here</a>, or see this post on <a href="https://twitter.com/good_in_theory/status/1477073821693886469">Twitter</a>.</em></p> <p>The <a href="https://adventofcode.com/">2021 Advent of Code</a> challenge has just ended. Typically, I do the problems in Python or Julia &#40;or, this year, some in Dart&#41;, but this time I also solved the first day’s problem using <a href="https://esolangs.org/wiki/Aheui">아희 &#40;Aheui&#41;</a>, a Korean esoteric programming language. On top of this, I hooked up my <a href="https://github.com/mcognetta/aheuiPython">아희 interpreter</a> to the <a href="https://www.manim.community/">Manim animation library</a> to generate animations that show the internal state of the 아희 program as it executes&#33;</p> <video controls autoplay muted> <source type="video/mp4" src="/assets/aheui-aoc-post/p1_en.mp4"> </video> <h3 id="아희_crash_course"><a href="#아희_crash_course" class=header-anchor >아희 Crash Course</a></h3> <p>To understand the rest of this post, one should first be familiar with 아희. There is a complete <a href="https://aheui.readthedocs.io/ko/latest/specs.en.html">English specification</a>, but here I will introduce the main themes of the language.</p> <p>아희 is written as a 2-dimensional grid of Korean characters. Each Korean character encodes an instruction &#40;<code>add</code>, <code>subtract</code>, <code>push</code>, <code>swap</code>, etc&#41;, a direction, and possibly some parameters for the function.</p> <p>For example, here is a program that outputs <code>Hello, world&#33;</code>:</p> <pre><code class="julia hljs">밤밣따빠밣밟따뿌
빠맣파빨받밤뚜뭏
돋밬탕빠맣붏두붇
볻뫃박발뚷투뭏붖
뫃도뫃희멓뭏뭏붘
뫃봌토범더벌뿌뚜
뽑뽀멓멓더벓뻐뚠
뽀덩벐멓뻐덕더벅</code></pre> <p>Korean characters are made up of three parts: the initial consonant, a vowel, and an &#40;optional&#41; final consonant. For example, <code>한</code> is <code>ㅎ/ㅏ/ㄴ</code> and <code>가</code> is <code>ㄱ/ㅏ</code> &#40;with no final consonant&#41;. When reading a character, the top or top-left section is the initial consonant. The middle/middle-right/right is the vowel, and the bottom is the final consonant. A visual introduction can be found <a href="http://easykorean.edsoftapps.com/learn-structure-of-hangul/">here</a>.</p> <p>In 아희, the initial consonant determines the instruction. A full list of these can be found in the specification, but later on I will provide a list of the relevant ones for this post.</p> <p>The directional information is provided by the vowel. As you execute an 아희 program, you traverse the grid with some momentum. When you execute a command, the vowel tells you how to update your momentum, and then you can determine the next cell. Conveniently, the vowel/direction mappings are determined by the shape of the vowel. For example, <code>ㅏ</code> means “your new momentum is right with magnitude 1”. Likewise, <code>ㅜ</code> would give a downwards momentum with magnitude 1. Vowels like <code>ㅑ/ㅕ/ㅛ/ㅠ</code> are the same but with magnitude 2. Other vowels reflect the momentum, and some have no effect. One other key feature is that, if an instruction fails &#40;for example, if the instruction is <code>add</code>, but an invalid parameter is passed&#41;, the momentum information is reflected &#40;so that <code>ㅏ</code> would act as <code>ㅓ</code>&#41;.</p> <p>The final consonant acts as a parameter to some instructions and has no effect on others. Depending on the instruction, the final consonant can act as a pointer to select certain things &#40;mainly data structures&#41;, or it can act as some numerical consonant. In the chart of instructions below, the effect of the final consonant is given.</p> <p>An 아희 program has access to several data structures: 26 stacks, 1 queue, and 1 undefined extension protocol. Each data structure is mapped to one final consonant so that they can be easily indexed. At any time during the execution of a program, there is one “active” data structure, upon which instructions can act. The <code>ㅅ</code> command allows one to select a new active data structure.</p> <p>아희 programs begin at the top left of the 2-d code grid, and execute continuously until a cell with the instruction <code>ㅎ</code> is reached, which immediately terminates the program.</p> <h4 id="a_slight_modification_to_the_아희_specification"><a href="#a_slight_modification_to_the_아희_specification" class=header-anchor >A Slight Modification to the 아희 Specification</a></h4> <p>아희 allows for reading from user input &#40;via the <code>ㅂ</code>-push instruction with a <code>ㅇ</code> or <code>ㅎ</code> final-consonant parameter&#41;. However, this does not necessarily cover reading from a piped in file &#40;which is required here, as Advent of Code inputs are given as text files&#41;. I slightly deviated from the specification in my interpreter to make the <code>ㅂ</code>-push instruction read from an input file, with the condition that, if a read is performed after the end-of-file had been reached, it would count as a failed instruction &#40;and so the direction information would be reversed, as explained above&#41;.</p> <h3 id=advent_of_code_day_1_solution ><a href="#advent_of_code_day_1_solution" class=header-anchor >Advent of Code Day 1 Solution</a></h3> <p>This year, the <a href="https://adventofcode.com/2021/day/1">first day&#39;s problem</a> was roughly: “in a list of numbers, how many times is a number immediately followed by a larger number?” For example, if the list was <code>1, 4, 2, 5, 7</code> , then the pairs <code>1-&gt;4, 2-&gt;5, 5-&gt;7</code> means the correct answer must be <code>3</code>.</p> <p>In Python, a possible solution is:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> __name__ == <span class=hljs-string >&#x27;__main__&#x27;</span>:
    f = <span class=hljs-built_in >open</span>(<span class=hljs-string >&#x27;input.txt&#x27;</span>, <span class=hljs-string >&#x27;r&#x27;</span>)
    x = <span class=hljs-built_in >int</span>(f.readline())
    count = <span class=hljs-number >0</span>
    <span class=hljs-keyword >for</span> line <span class=hljs-keyword >in</span> f:
        y = <span class=hljs-built_in >int</span>(line)
        <span class=hljs-keyword >if</span> y &gt; x: count += <span class=hljs-number >1</span>
        x = y
    <span class=hljs-built_in >print</span>(count)</code></pre> <p>In 아희, I solved it in the following way:</p> <pre><code class="julia hljs">삼바상뱡숨방파빠파주
마르코하멍송더섬썸퍼</code></pre> <p>There are several instructions used in this program &#40;listed here in Korean alphabetical order&#41;:</p> <ul> <li><p><code>ㄷ</code> -&gt; add</p> <ul> <li><p>From the active data structure, pop the top two values, add them, and push them back to the data structure.</p> <li><p>The final consonant has no effect.</p> </ul> <li><p><code>ㅅ</code> -&gt; select a data structure</p> <ul> <li><p>Select a new active data structure.</p> <li><p>The final consonant specifies the data structure to select.</p> <li><p>In this program, we use:</p> <ul> <li><p><code>ㅁ</code> -&gt; queue</p> <li><p><code>ㅇ</code> -&gt; a stack</p> </ul> </ul> <li><p><code>ㅂ</code> -&gt; push an item to the active data structure</p> <ul> <li><p>If the final consonant is <code>ㅇ</code>, read from the input file and push the value.</p> <li><p>If there is no final consonant, push a <code>0</code>.</p> <li><p>Otherwise, &#40;except for <code>ㅎ</code>&#41; push an integer based on the number of lines in the final consonant.</p> <ul> <li><p><code>ㄱ -&gt; 2</code></p> <li><p><code>ㅃ -&gt; 8</code></p> </ul> </ul> <li><p><code>ㅍ</code> -&gt; swap</p> <ul> <li><p>Swap the top two values in the active data structure.</p> <ul> <li><p>Note that this does not pop and then push, but swaps them in-place.</p> </ul> <li><p>The final consonant has no effect.</p> </ul> <li><p><code>ㅃ</code> -&gt; duplicate</p> <ul> <li><p>Copy the top value of the active data structure and push it.</p> <li><p>The final consonant has no effect.</p> </ul> <li><p><code>ㅈ</code> -&gt; compare</p> <ul> <li><p>Pop the top two values of the current data structure, compare them, and push <code>0</code> or <code>1</code> depending on the result.</p> <li><p>The final consonant has no effect.</p> </ul> <li><p><code>ㅆ</code> -&gt; transfer</p> <ul> <li><p>Pop the top value of the active data structure and push it to the data structure indexed by the final consonant.</p> </ul> <li><p><code>ㅁ</code> -&gt; print</p> <ul> <li><p>Pop the top value of the active data structure, and print the result.</p> <li><p>If the final consonant is <code>ㅇ</code>, print it as an integer.</p> <li><p>If the final consonant is <code>ㅎ</code>, print the Unicode character corresponding to the value.</p> </ul> <li><p><code>ㅎ</code> -&gt; terminate</p> <ul> <li><p>Immediately end the program. </p> <li><p>The final consonant has no effect.</p> </ul> </ul> <p><br /></p> <pre><code class="julia hljs">삼바상뱡숨방파빠파주
마르코하멍송더섬썸퍼</code></pre> <p>My solution contains 4 parts. The first part is the top left corner <code>삼바상뱡</code>, which is intended to initialize the program. The <code>ㅁ</code>-stack will hold a counter, and so we initialize it with zero via <code>삼바</code> &#40;select <code>ㅁ</code>-stack, push <code>0</code>&#41;. The <code>ㅇ</code>-queue will process each element from the input file as it comes in, so we initialize it with the first value in the file via <code>상뱡</code> &#40;select <code>ㅇ</code>-queue, read stdin&#41;. Notice that <code>뱡</code> has momentum 2, so when it successfully runs, the next cell will be two to the right, <code>방</code>, not <code>숨</code>.</p> <p>The second part is the main logic:</p> <pre><code class="julia hljs">방파빠파주
송더섬썸퍼</code></pre> <p>Notice that the vowels here form a cycle: <code>방 -&gt; 파 -&gt; 빠 -&gt; 파 -&gt; 주 -&gt; 퍼 -&gt; 썸 -&gt; 섬 -&gt; 더 -&gt; 송 -&gt; 방 -&gt; ...</code>. This cycle is designed to repeat until the <code>방</code> instruction fails &#40;meaning that the end-of-file has been reached&#41;.</p> <p>At the start of this cycle, the active data structure is the <code>ㅇ</code>-queue, which contains one element, the first number in the file. This cycle performs the following actions:</p> <ul> <li><p>Read a number and push it to the queue &#40;<code>방</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;new, old&#93;</code>.</p> </ul> <li><p>Swap the new and old numbers &#40;so the new one is at the front&#41; &#40;<code>파</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;old, new&#93;</code>.</p> </ul> <li><p>Duplicate the new number &#40;and push it to the queue&#41; &#40;<code>빠</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;new, old, new&#93;</code>.</p> <li><p>This is in preparation for the next iteration of the cycle, when the just-read “new” number is the “old” number.</p> </ul> <li><p>Restore the original order of the old and new numbers &#40;<code>파</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;new, new, old&#93;</code>.</p> </ul> <li><p>Compare the old and new numbers &#40;and push the result to the queue&#41; &#40;<code>주</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;result, new&#93;</code>.</p> </ul> <li><p>Swap the top elements of the queue, so the result is on top &#40;<code>파</code>&#41;.</p> <ul> <li><p>The queue is now <code>&#91;new, result&#93;</code>.</p> </ul> <li><p>Send the result to the counter <code>ㅁ</code>-stack &#40;<code>썸</code>&#41;.</p> <ul> <li><p>The <code>ㅁ</code>-stack is now <code>&#91;count, result&#93;</code>.</p> </ul> <li><p>Make the counter <code>ㅁ</code>-stack the active data structure &#40;<code>섬</code>&#41;.</p> <li><p>Sum the top two elements of the count stack &#40;<code>더</code>&#41;.</p> <ul> <li><p>The <code>ㅁ</code>-stack is now <code>&#91;counter &#43; result&#93;</code>.</p> </ul> <li><p>Switch to the queue &#40;<code>송</code>&#41;.</p> </ul> <p>At this point, we are back at the start of the cycle, and can repeat.</p> <p>When the <code>방</code> at the start of the cycle fails &#40;that is, after we have reached the end-of-file&#41;, the direction is reversed, and we move to the third section:</p> <pre><code class="julia hljs">....숨..
..하멍..</code></pre> <p>Here, we switch to the counter <code>ㅁ</code>-stack &#40;<code>숨</code>&#41;, print the value &#40;<code>멍</code>&#41;, and terminate &#40;<code>허</code>&#41;.</p> <p>The last section, <code>마르코</code>, is just my name. It is unreachable, and so it is never executed. I put it there both for flair and to preserve the rectangular shape of the program.</p> <h4 id=demonstration ><a href="#demonstration" class=header-anchor >Demonstration</a></h4> <p>The flow of the program can be understood visually. The first animation covers the initialization of the program and several iterations of the main logic cycle.</p> <video controls autoplay muted> <source type="video/mp4" src="/assets/aheui-aoc-post/p1_en.mp4"> </video> <p>And this animation demonstrates how the program breaks out of the cycle when the end-of-file is reached.</p> <video controls autoplay muted> <source type="video/mp4" src="/assets/aheui-aoc-post/p1_end_en.mp4"> </video> <h3 id=day_1_part_2 ><a href="#day_1_part_2" class=header-anchor >Day 1, Part 2</a></h3> <p>The first day&#39;s puzzle has a second part, which is a slight variant of the problem above. In this case, rather than comparing each adjacent number, we compare the sum of each successive set of three numbers. For example, if the list was <code>1, 4, 2, 5, 7</code>, we would compare <code>1 &#43; 4 &#43; 2</code> to <code>4 &#43; 2 &#43; 5</code> to see if the second sum was bigger.</p> <p>In Python, one can solve it like so:</p> <pre><code class="python hljs"><span class=hljs-keyword >if</span> __name__ == <span class=hljs-string >&#x27;__main__&#x27;</span>:
    count = <span class=hljs-number >0</span>
    f = <span class=hljs-built_in >open</span>(<span class=hljs-string >&#x27;input.txt&#x27;</span>, <span class=hljs-string >&#x27;r&#x27;</span>)
    x, y, z = <span class=hljs-built_in >int</span>(f.readline()), <span class=hljs-built_in >int</span>(f.readline()), <span class=hljs-built_in >int</span>(f.readline())

    <span class=hljs-keyword >for</span> line <span class=hljs-keyword >in</span> f:
        a = <span class=hljs-built_in >int</span>(line)
        <span class=hljs-keyword >if</span> a &gt; x: count += <span class=hljs-number >1</span>
        x, y, z = y, z, a
    <span class=hljs-built_in >print</span>(count)</code></pre> <p>Note that we make use of the fact that <code>x &#43; y &#43; z &lt; y &#43; z &#43; a</code> can be determined by checking <code>x &lt; a</code>.</p> <p>I also solved this problem with the following 아희 code:</p> <pre><code class="julia hljs">삼바상방방방샨숨방빠쌍상싼산반분
마르코코그넷허멍손더섬썸저어더너</code></pre> <p><br /> <video controls autoplay muted> <source type="video/mp4" src="/assets/aheui-aoc-post/p2_en.mp4"> </video> </p> <p><br /> This again has 4 parts. <code>삼바상방방방샨</code> initializes the program. In this program, we have a counter stack &#40;<code>ㅁ</code>-stack&#41;, a “workspace” stack &#40;<code>ㄴ</code>-stack&#41;, and a queue &#40;<code>ㅇ</code>-queue&#41;. The queue will hold the current 3 numbers whose sum we are comparing against, with the oldest number at the front of the queue. We initialize the program by pushing a <code>0</code> to the counter <code>ㅁ</code>-stack, then reading the first three numbers to the queue, and finally reading the 4th number to the <code>ㄴ</code>-stack.</p> <p>The main logic is again a loop:</p> <pre><code class="julia hljs">방빠쌍상싼산반분
손더섬썸저어더너</code></pre> <p>At the start, the active data structure is the <code>ㄴ</code>-stack, which holds just the newest number &#40;<code>x&#91;i&#93;</code>&#41;. The queue holds <code>&#91;x&#91;i-3&#93;, x&#91;i-2&#93;, x&#91;i-1&#93;&#93;</code>. Here, we copy the just-read number and send it to the back of the queue, to prepare for the next iteration. Then, we send the front of the queue &#40;the oldest number in the current set&#41; to the <code>ㄴ</code>-stack, so it can be compared with the just-read in number.</p> <p>In part one, we also had to do a comparison between old and new numbers. The <code>ㅈ</code>-compare command acts as a <code>≥</code>, but what this question requires is <code>&gt;</code>. It turns out that there aren’t cases of <code>x&#91;i&#93; &#61;&#61; x&#91;i-1&#93;</code> in the input &#40;at least, in my input&#41;, but there are many cases of <code>x&#91;i&#93; &#61;&#61; x&#91;i-3&#93;</code>. This means that we cannot compare the old and new numbers directly with <code>ㅈ</code>, as it would over count &#40;when the triplet sums are equal&#41;. To avoid this, we add one to the older number, so that <code>ㅈ</code> returns <code>1</code> only when the new number is strictly larger &#40;that is, <code>new ≥ old &#43; 1</code>&#41;.</p> <p>In 아희, there is no way to directly push a <code>1</code> into a stack &#40;recall that <code>ㅂ</code>-push pushes a value based on the number of lines in the final consonant; since <code>ㅇ</code> is already reserved for reading from stdin, there are no available final consonants with only one line&#41;. One way to input a one is to push the same value twice and then divide &#40;the <code>ㄴ</code> command&#41;. This is done with <code>반/분/너</code>, which pushes a <code>2</code> twice and then divides, leaving <code>1</code>. Once the addition and comparison are done, the counter is updated and the loop starts over &#40;so that now, the queue holds <code>&#91;x&#91;i-2&#93;, x&#91;i-1&#93;, x&#91;i&#93;&#93;</code> and the <code>ㄴ</code>-stack holds <code>&#91;x&#91;i&#43;1&#93;&#93;</code>&#41;.</p> <p>In addition to <code>ㄴ</code>-divide, one other new instruction is present in this program, <code>ㅇ</code> &#40;seen in the <code>어</code> character&#41;. This is the &quot;no op&quot; instruction, and it does nothing &#40;but the vowel can still have an effect&#41;. It is typically used to preserve the layout of the program, or for program flow. Here we use it to preserve the rectangular structure of the loop.</p> <p>Exactly like the first problem, when the end-of-file is reached, the beginning of the loop <code>방</code> instruction fails, sending the program to the third section:</p> <pre><code class="julia hljs">....숨...
..허멍..</code></pre> <p>which prints the counter value and terminates.</p> <p>Again, the fourth section: <code>마르코코그넷허</code> is my name. Unfortunately, this is not how I typically spell my name. The correct version, <code>마르코 코그넷*터*</code> would not fit while preserving the rectangular shape, so I combined the <code>넷터</code> and terminating <code>허</code> into <code>넷허</code>, which has a similar pronunciation.</p> <div class=page-foot > <div class=copyright > &copy; Marco Cognetta. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>. </div> </div> </div> </div> </div> <label for=sidebar-checkbox  class=sidebar-toggle ></label>