<!doctype html> <html lang=en > <script async src="https://www.googletagmanager.com/gtag/js?id=UA-155225320-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-155225320-2'); </script> <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/poole_lanyon.css"> <link rel=stylesheet  href="/css/adjust.css"> <link rel=icon  href="/assets/favicon.ico"> <title>Discord Bot for Esperanto Transcription</title> <input type=checkbox  class=sidebar-checkbox  id=sidebar-checkbox > <div class=sidebar  id=sidebar > <div class=sidebar-item > <p>theoretically good with computers</a>.</p> </div> <nav class=sidebar-nav > <a class="sidebar-nav-item " href="/">home</a> <a class="sidebar-nav-item " href="/posts/">posts</a> <a class="sidebar-nav-item " href="https://dblp1.uni-trier.de/pers/hd/c/Cognetta:Marco">publications</a> <a class="sidebar-nav-item " href="https://github.com/mcognetta">github</a> <a class="sidebar-nav-item " href="https://www.linkedin.com/in/mcognetta/">linkedin</a> <a class="sidebar-nav-item " href="assets/mccv.pdf">cv</a> <a class="sidebar-nav-item " href="/tags">all tags</a> </nav> <div class=sidebar-item > <p>&copy; Marco Cognetta.</p> </div> </div> <!-- Wrap is the content to shift when toggling the sidebar. We wrap the content to avoid any CSS collisions with our real content. --> <div class=wrap > <div class=masthead > <div class=container > <h3 class=masthead-title > <a href="/" title=Home >marco cognetta</a> <small>theoretically good with computers</small> </h3> </div> </div> <div class="container content"> <div class=franklin-content ><h1 id=x-system_transcription_discord_bot ><a href="#x-system_transcription_discord_bot" class=header-anchor >X-System Transcription Discord Bot</a></h1> <p>The code for this bot can be found at <a href="https://github.com/mcognetta/transskribilo-boto">https://github.com/mcognetta/transskribilo-boto</a>.</p> <p>In the days before Unicode, typists had to improvise when typing characters with diacritics &#40;ĉ, ŭ, etc.&#41;. A popular system for marking diacritics was the “x-system”, where one simply placed an “x” immediately after the character that they wanted to mark with a diacritic &#40;cx -&gt; ĉ, ux -&gt; ŭ, etc.&#41;. There are some problems with this system though. For example, there may be more than one viable diacritic for a character in a context or there may be ambiguity between diacritic-marking x’s and literal x’s. However, the x-system took off for Esperanto, which does not have any of the aforementioned issues for pure Esperanto words.</p> <p>These days, Esperanto language input methods are common, but people may not use them for a variety of reasons. It is still normal to see lots of text in chat rooms and on forums that use the x-system. I noticed that many users were still using the x-system even in the Esperanto community Discord channels, so I developed a small bot to automatically transcribe x-system text into the correct Unicode characters, so that a user could simply type as they wanted and the bot would handle the rest without prompting.</p> <p><img src="/assets/discord-bot-post/bona.gif" alt=bona  /></p> <p>As you can see, the x-system text is deleted and a new message with Unicode appears in its place. The username and profile picture match the original sender’s so as to not inhibit the flow of conversation.</p> <p>The system I used to implement this is very simple. I simply assumed that all text in the channels with this bot would be in Esperanto, and so all *-x text should be reinterpreted as Unicode. This can lead to incorrect transcriptions. In this case, the user should be able to revert the change on command.</p> <p><img src="/assets/discord-bot-post/pardonu.gif" alt=pardonu  /></p> <p>Obviously, there are still some edge cases that exist – for example, it is not possible for a user to revert only one word’s transcription in a message – but for most cases, it gets the job done. The bot is also explicitly opt-in. In my server, it only corrects text typed by users with the “aŭttransskribiĝebla” role.</p> <h2 id=implementation ><a href="#implementation" class=header-anchor >Implementation</a></h2> <p>I used <a href="https://github.com/Rapptz/discord.py">Discord.py</a>, a fantastic Python API wrapper for Discord. One limitation of the Discord API is that bots cannot edit messages that were not created by them. This prohibits the most straightforward implementation where the bot just edits the content of a message to replace it with the Unicode transcription.</p> <p>To get around this, I used <a href="https://discordpy.readthedocs.io/en/stable/api.html#webhook">Webhooks</a>, a method for sending messages to channels without using a bot or being a user. Webhooks allow for providing arbitrary message content and author information, so the original author’s information can be replicated. The transcribed message is then sent via the webhook and the original message is deleted, giving the appearance of it being edited.</p> <p>The main message processing function looked something like this:</p> <pre><code class="python hljs"><span class=hljs-meta >@bot.event</span>
<span class=hljs-keyword >async</span> <span class=hljs-keyword >def</span> <span class="hljs-title function_">on_message</span>(<span class=hljs-params >message</span>):
    author, content = message.author, message.content

    <span class=hljs-comment ># filter out messages we don&#x27;t want to process</span>
    <span class=hljs-comment ># for example, users who have not opted in or messages</span>
    <span class=hljs-comment ># that contain files, etc. that we do not want to be</span>
    <span class=hljs-comment ># responsible for</span>
    <span class=hljs-keyword >if</span> _message_metadata_filter(message):

        <span class=hljs-comment ># a transcription function that returns a flag indicating</span>
        <span class=hljs-comment ># if any changes were made and the (possibly) edited text</span>
        replaced, edited_text = replacer(content)

        <span class=hljs-keyword >if</span> replaced:
            hook = <span class=hljs-keyword >await</span> message.channel.create_webhook(name=<span class=hljs-string >&quot;bot&quot;</span>)
            <span class=hljs-keyword >await</span> message.delete()
            
            <span class=hljs-comment ># send the transcribed message via the webhook</span>
            <span class=hljs-comment ># with the original author&#x27;s information</span>
            webhook_msg = <span class=hljs-keyword >await</span> hook.send(
                edited_text,
                username=author.display_name + <span class=hljs-string >&quot; | (transskribita)&quot;</span>,
                avatar_url=author.avatar_url,
                <span class=hljs-comment ># allows the webhook message info to be cached</span>
                wait=<span class=hljs-literal >True</span>,
            )
            
            <span class=hljs-comment ># stores the message in an LRU cache in case of</span>
            <span class=hljs-comment ># an undo command</span>
            _queue_msg(author, content, channel, webhook_msg)
            <span class=hljs-keyword >await</span> hook.delete()

    <span class=hljs-keyword >await</span> bot.process_commands(message)</code></pre> <p>There is also an undo &#40;<code>&#33;malfaru</code>&#41; function that deletes the edited message and replaces it with the original &#40;again sent by a webhook&#41;. I imposed a cache size limit of 100 messages and implemented it as a plain deque. This is not ideal but can easily be changed in the event that this bot gets serious use.</p> <h2 id=esperanto ><a href="#esperanto" class=header-anchor >Esperanto</a></h2> <p>In case you were wondering about some of the Esperanto terms that were used, here is a quick summary.</p> <p>The bot’s name is “transskribilo”, meaning “a tool for transcription”. The undo command is “malfaru”, the imperative mood of “to undo”. The opt-in role is “aŭttransskribiĝebla” meaning “able to be automatically transcribed”. The text that appears after the username in transcribed messages is “&#40;transkribita&#41;”, the passive past participle “having been transcribed”. Finally, the reaction text that appears on <code>&#33;malfaru</code> commands is “pardonu”, short for “pardonu min”, meaning “pardon me”.</p> <p>Of these, aŭttransskribiĝebla is the most interesting grammatically. It is parsed as aŭt·trans·skrib·iĝ·ebl·a. “Aŭt-“ is the root for aŭto &#40;as in automatically&#41;, “trans-“ and “skrib-“ combined give the root for “to transcribe”, “-iĝ-” is a suffix for turning an active verb into the passive voice, “-ebl-” is a suffix for “able to”, and “-a” is the adjective marker suffix.</p> <p>Ĝis&#33;</p> <div class=page-foot > <div class=copyright > &copy; Marco Cognetta. Last modified: December 11, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>. </div> </div> </div> </div> </div> <label for=sidebar-checkbox  class=sidebar-toggle ></label>