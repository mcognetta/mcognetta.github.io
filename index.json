[{"authors":["admin"],"categories":null,"content":"I am currently a software engineer at Google. I did my Masters in Computer Science at Yonsei University and my Undergrad in Discrete Mathematics at Georgia Tech.\nI am always open to chatting about interesting topics. Please feel free to send me an email.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://mcognetta.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am currently a software engineer at Google. I did my Masters in Computer Science at Yonsei University and my Undergrad in Discrete Mathematics at Georgia Tech.\nI am always open to chatting about interesting topics. Please feel free to send me an email.","tags":null,"title":"Marco Cognetta","type":"authors"},{"authors":[""],"categories":["Julia"],"content":" A gist with the code in this post can be found here.\nWhen planning a small library in Julia, I kept running into a similar problem across all of the type systems that I tried when looking for the proper abstraction. Briefly, I had a single parametric abstract type at the top of an arbitrary type hierarchy (with any number of abstract and concrete types below it, possibly added later by a user) and I needed to write a function that would only work on objects with the same UnionAll1 types. Furthermore, I wanted this to be automatic for all of the types in the aforementioned hierarchy without the user having to write any code.\nHere is a basic example. Suppose I have the types:\nabstract type A{T} end struct B{T} \u0026lt;: A{T} end struct C{T} \u0026lt;: A{T} end abstract type D{T} \u0026lt;: A{T} end struct E{T} \u0026lt;: D{T} end struct F{T} \u0026lt;: D{T} end  Here, D, E, and F are included to demonstrate that the type hierarchy can be arbitrarily complex and extended at any time by the user.\nI want to define a function f(x, y) that does something when x and y come from the same UnionAll type, even if they are parameterized differently, and fails otherwise. For example:\nx = B{Int64}() y = B{Float32}() z = C{Int64}() f(x, y) # -\u0026gt; does something f(x, z) # -\u0026gt; fails f(y, z) # -\u0026gt; fails  A simple solution to this is to just require the user to implement f for their new types while providing a fall back f(::A, ::A) that fails. However, the library that I am writing has a very natural interface and adding more to it would have been undesirable. Also, this struck me as something that should be possible programmatically.\nMy first attempt to do it programmatically lead to method signatures similar to:\nNB: this is neither valid nor good Julia code 2 f(::X, ::Y) where {T, S, U\u0026lt;:A, X\u0026lt;:U{T}, Y\u0026lt;:U{S}} = ...  I was then pointed (by a JuliaLang member on Slack, though I can\u0026rsquo;t remember who) to a partial solution of determining if two objects had the same UnionAll type:\nsameunionall(::X, ::Y) where {X\u0026lt;:A, Y\u0026lt;:A} = !isabstracttype(typejoin(X, Y))  This can be rewritten for types as:\nsameunionall(::Type{X}, ::Type{Y}) where {X\u0026lt;:A, Y\u0026lt;:A} = !isabstracttype(typejoin(X, Y))  Combining this with \u0026lsquo;Holy-Traits\u0026rsquo; 3 via SimpleTraits.jl leads to a nice solution:\nusing SimpleTraits @traitdef SameUnionAll{X, Y} @traitimpl SameUnionAll{X, Y} \u0026lt;- sameunionall(X, Y) @traitfn f(::X, ::Y) where {X\u0026lt;:A, Y\u0026lt;:A; SameUnionAll{X, Y}} = \u0026quot;yo\u0026quot; @traitfn f(::X, ::Y) where {X\u0026lt;:A, Y\u0026lt;:A; !SameUnionAll{X, Y}} = \u0026quot;nah\u0026quot;  This can be tested out:\nx = B{Int64}() y = B{Float32}() z = C{Int64}() f(x, y) # -\u0026gt; \u0026quot;yo\u0026quot; f(x, z) # -\u0026gt; \u0026quot;nah\u0026quot; f(y, z) # -\u0026gt; \u0026quot;nah\u0026quot; # added later by a user struct G{T} \u0026lt;: D{T} end f(G{Int16}(), x) # -\u0026gt; \u0026quot;nah\u0026quot; f(G{Int16}(), G{BigFloat}()) # -\u0026gt; \u0026quot;yo\u0026quot;  One important note is that sameunionall is a pure method so f does not fall back to dynamic dispatch. This can be verified by checking:\njulia\u0026gt; @code_warntype f(x, y) Body::String 1 ─ return \u0026quot;yo\u0026quot; julia\u0026gt; @code_warntype f(x, z) Body::String 1 ─ return \u0026quot;nah\u0026quot;  This trick will be expanded on in a future post, but to whet the appetite I will briefly introduce the exact use case that I have. Suppose I have the following structure, where more \u0026ldquo;special algebra\u0026rdquo; types can be added at will by the user:\nabstract type AbstractAlgebraElement{T} end struct SpecialAlgebraElement{T\u0026lt;:Real} \u0026lt;: AbstractAlgebraElement{T} end struct DifferentAlgebraElement{T\u0026lt;:Number} \u0026lt;: AbstractAlgebraElement{T} end  Objects of the same algebraic type but with different parameters should be compatible (for example, a ring of real numbers represented by Float32 vs one represented by Float64 are essentially the same thing here). As such, we should be able to promote between them so that this should work:\npromote_type(SpecialAlgebraElement{Float64}, SpecialAlgebraElement{Float16}) # -\u0026gt; SpecialAlgebraElement{Float64}  but this should fail:\npromote_type(SpecialAlgebraElement{Float64}, DifferentAlgebraElement{Float16})  As a final note, more idiomatic Julia code, comments, criticisms, etc. are always welcome. Please feel free to email me.\n https://docs.julialang.org/en/v1/manual/types/index.html#UnionAll-Types-1 ^ Examples of good but not valid Julia code are left as an exercise. ^ https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633 ^   ","date":1565729068,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1565729068,"objectID":"1168ed80d9ef1f868df2fde75f99d630","permalink":"https://mcognetta.github.io/post/dispatch_unionall/","publishdate":"2019-08-13T16:44:28-04:00","relpermalink":"/post/dispatch_unionall/","section":"post","summary":"A gist with the code in this post can be found here.\nWhen planning a small library in Julia, I kept running into a similar problem across all of the type systems that I tried when looking for the proper abstraction. Briefly, I had a single parametric abstract type at the top of an arbitrary type hierarchy (with any number of abstract and concrete types below it, possibly added later by a user) and I needed to write a function that would only work on objects with the same UnionAll1 types.","tags":["Julia"],"title":"Dispatching on types with the same UnionAll (but you don't know the types beforehand)","type":"post"}]